type InputValue = string | number | bigint;

export type InputRecord = Record<string, InputValue>;
export type WitnessRecord = Record<string, string>;

export interface WitnessModuleExports {
  default?: (input?: unknown) => Promise<unknown> | unknown;
  compute_witness: (inputs: Record<string, string>) => unknown;
}

export interface ProverModuleExports {
  default?: (input?: unknown) => Promise<unknown> | unknown;
  init_panic_hook?: () => void;
  WasmProver: new (r1csBytes: Uint8Array, provingKeyBytes: Uint8Array) => WasmProverLike;
}

export interface WasmProverLike {
  prove(witnessValues: string[]): Uint8Array | Promise<Uint8Array>;
}

export interface CreateLofCircuitOptions {
  /**
   * Ordered list of public input signal names. Required for witness packing.
   */
  publicSignals: string[];
  /**
   * Ordered list of private witness signal names. Required for witness packing.
   */
  witnessSignals: string[];

  /**
   * Optional bundle root where the compiled assets live (e.g. `/static/loan_eligibility`).
   * Used to derive default URLs when explicit paths are omitted.
   */
  bundleRoot?: string;
  /**
   * Optional base name for the circuit artifacts (defaults to the final path segment of `bundleRoot`).
   */
  artifactName?: string;

  /**
   * Provide pre-fetched R1CS bytes. If omitted, `r1csUrl` must be supplied.
   */
  r1cs?: Uint8Array;
  /**
   * Fetch the R1CS file from this URL when `r1cs` is not provided.
   */
  r1csUrl?: string;
  /**
   * Provide pre-fetched proving key bytes. If omitted, `provingKeyUrl` must be supplied.
   */
  provingKey?: Uint8Array;
  /**
   * Fetch the proving key from this URL when `provingKey` is not provided.
   */
  provingKeyUrl?: string;

  /**
   * Custom fetch implementation (useful for tests or polyfills).
   */
  fetch?: typeof fetch;

  /**
   * Witness module exports generated by wasm-pack. Supply this when bundlers
   * handle the import for you.
   */
  witnessModule?: WitnessModuleExports;
  /**
   * Lazily load the witness module. Called when `witnessModule` is omitted.
   */
  loadWitnessModule?: () => Promise<WitnessModuleExports>;
  /**
   * URL passed to the default dynamic import helper when no loader or module is provided.
   */
  witnessModuleUrl?: string;
  /**
   * Optional argument forwarded to the witness module's default initializer.
   */
  witnessModuleInitArg?: unknown;

  /**
   * Prover module exports (from wasm-pack). Provide this when bundlers resolve the import statically.
   */
  proverModule?: ProverModuleExports;
  /**
   * Lazily load the prover module. Called when `proverModule` is omitted.
   */
  loadProverModule?: () => Promise<ProverModuleExports>;
  /**
   * URL passed to the default dynamic import helper when no loader or module is provided.
   */
  proverModuleUrl?: string;
  /**
   * Optional argument forwarded to the prover module's default initializer.
   */
  proverModuleInitArg?: unknown;
}

export interface ProofArtifacts {
  proofBytes: Uint8Array;
  witness: WitnessRecord;
  witnessArray: string[];
  publicInputs: Record<string, string>;
}

export interface LofCircuit {
  readonly publicSignals: readonly string[];
  readonly witnessSignals: readonly string[];
  /**
   * Computes the circuit witness for the provided input record.
   */
  computeWitness(inputs: InputRecord): WitnessRecord;
  /**
   * Packs a witness record into the canonical order expected by the prover.
   */
  buildWitnessArray(witness: WitnessRecord): string[];
  /**
   * Extracts the public inputs from a witness record.
   */
  buildPublicInputs(witness: WitnessRecord): Record<string, string>;
  /**
   * Generates a Groth16 proof for the supplied inputs, returning the proof bytes
   * and helpful metadata.
   */
  generateProof(inputs: InputRecord): Promise<ProofArtifacts>;
  /**
   * Access to the underlying WasmProver instance for advanced use-cases.
   */
  getProver(): WasmProverLike;
}

export async function createLofCircuit(
  options: CreateLofCircuitOptions
): Promise<LofCircuit> {
  const opts: CreateLofCircuitOptions = { ...options };
  const publicSignals = [...opts.publicSignals];
  const witnessSignals = [...opts.witnessSignals];

  if (publicSignals.length === 0 && witnessSignals.length === 0) {
    throw new Error(
      'createLofCircuit: at least one signal is required to build the witness layout'
    );
  }

  const fetchImpl = opts.fetch ?? globalThis.fetch;
  if (!fetchImpl) {
    throw new Error(
      'createLofCircuit: global fetch is unavailable – supply a custom fetch implementation'
    );
  }

  const bundleRoot = normalizeBundleRoot(opts.bundleRoot);
  const artifactName = resolveArtifactName(opts, bundleRoot);

  const r1csUrl =
    opts.r1csUrl ??
    (bundleRoot && artifactName
      ? `${bundleRoot}/build/${artifactName}.r1cs`
      : undefined);
  const provingKeyUrl =
    opts.provingKeyUrl ??
    (bundleRoot && artifactName
      ? `${bundleRoot}/keys/${artifactName}_pk.bin`
      : undefined);
  const witnessModuleUrl =
    opts.witnessModuleUrl ??
    (bundleRoot && artifactName
      ? `${bundleRoot}/witness/${artifactName}_witness_wasm.js`
      : undefined);
  const proverModuleUrl =
    opts.proverModuleUrl ??
    (bundleRoot ? `${bundleRoot}/prover/lofit.js` : undefined);

  if (!opts.r1cs && !r1csUrl) {
    throw new Error('createLofCircuit: supply `r1cs`, `r1csUrl`, or `bundleRoot`/`artifactName`');
  }
  if (!opts.provingKey && !provingKeyUrl) {
    throw new Error('createLofCircuit: supply `provingKey`, `provingKeyUrl`, or `bundleRoot`/`artifactName`');
  }

  const [r1csBytes, provingKeyBytes] = await Promise.all([
    resolveBytes('r1cs', opts.r1cs, r1csUrl, fetchImpl),
    resolveBytes('proving key', opts.provingKey, provingKeyUrl, fetchImpl),
  ]);

  const witnessModule = await resolveWitnessModule({
    ...opts,
    witnessModuleUrl,
  });
  const proverModule = await resolveProverModule({
    ...opts,
    proverModuleUrl,
  });

  if (typeof witnessModule.compute_witness !== 'function') {
    throw new Error(
      'createLofCircuit: provided witness module does not expose compute_witness()'
    );
  }
  if (typeof proverModule.WasmProver !== 'function') {
    throw new Error(
      'createLofCircuit: provided prover module does not expose WasmProver'
    );
  }

  if (typeof witnessModule.default === 'function') {
    await witnessModule.default(opts.witnessModuleInitArg);
  }
  if (typeof proverModule.default === 'function') {
    await proverModule.default(opts.proverModuleInitArg);
  }
  if (typeof proverModule.init_panic_hook === 'function') {
    proverModule.init_panic_hook();
  }

  const prover = new proverModule.WasmProver(r1csBytes, provingKeyBytes);

  const circuit: LofCircuit = {
    publicSignals,
    witnessSignals,
    computeWitness(inputs: InputRecord): WitnessRecord {
      const normalized = normalizeInputs(inputs);
      const raw = witnessModule.compute_witness(normalized);
      return toWitnessRecord(raw);
    },
    buildWitnessArray(witness: WitnessRecord): string[] {
      return buildWitnessArray(publicSignals, witnessSignals, witness);
    },
    buildPublicInputs(witness: WitnessRecord): Record<string, string> {
      return buildPublicInputs(publicSignals, witness);
    },
    async generateProof(inputs: InputRecord): Promise<ProofArtifacts> {
      const witness = this.computeWitness(inputs);
      const witnessArray = this.buildWitnessArray(witness);
      const rawProof = await Promise.resolve(prover.prove(witnessArray));
      const proofBytes = coerceUint8Array(rawProof);
      const publicInputs = this.buildPublicInputs(witness);
      return { proofBytes, witness, witnessArray, publicInputs };
    },
    getProver(): WasmProverLike {
      return prover;
    },
  };

  return Object.freeze(circuit);
}

function normalizeInputs(inputs: InputRecord): Record<string, string> {
  const result: Record<string, string> = {};
  for (const [key, value] of Object.entries(inputs)) {
    result[key] = stringifyValue(value);
  }
  return result;
}

function buildWitnessArray(
  publicSignals: string[],
  witnessSignals: string[],
  witness: WitnessRecord
): string[] {
  const ordered: string[] = [];

  for (const signal of publicSignals) {
    if (!(signal in witness)) {
      throw new Error(
        `buildWitnessArray: missing public signal '${signal}' in witness output`
      );
    }
    ordered.push(stringifyValue(witness[signal]));
  }

  for (const signal of witnessSignals) {
    if (!(signal in witness)) {
      throw new Error(
        `buildWitnessArray: missing witness signal '${signal}' in witness output`
      );
    }
    ordered.push(stringifyValue(witness[signal]));
  }

  return ordered;
}

function buildPublicInputs(
  publicSignals: string[],
  witness: WitnessRecord
): Record<string, string> {
  const result: Record<string, string> = {};
  for (const signal of publicSignals) {
    if (!(signal in witness)) {
      throw new Error(
        `buildPublicInputs: missing public signal '${signal}' in witness output`
      );
    }
    result[signal] = stringifyValue(witness[signal]);
  }
  return result;
}

async function resolveBytes(
  label: string,
  existing: Uint8Array | undefined,
  url: string | undefined,
  fetchImpl: typeof fetch
): Promise<Uint8Array> {
  if (existing && existing.length > 0) {
    return existing;
  }
  if (!url) {
    throw new Error(
      `createLofCircuit: ${label} bytes missing – provide either the raw bytes or a URL`
    );
  }
  const response = await fetchImpl(url);
  if (!response.ok) {
    throw new Error(
      `createLofCircuit: failed to fetch ${label} from '${url}' (HTTP ${response.status})`
    );
  }
  const buffer = await response.arrayBuffer();
  return new Uint8Array(buffer);
}

async function resolveWitnessModule(
  options: CreateLofCircuitOptions
): Promise<WitnessModuleExports> {
  if (options.witnessModule) {
    return options.witnessModule;
  }
  if (options.loadWitnessModule) {
    return options.loadWitnessModule();
  }
  if (options.witnessModuleUrl) {
    return dynamicImport<WitnessModuleExports>(options.witnessModuleUrl);
  }
  throw new Error(
    'createLofCircuit: witness module not provided – supply `witnessModule`, `loadWitnessModule`, or `witnessModuleUrl`'
  );
}

async function resolveProverModule(
  options: CreateLofCircuitOptions
): Promise<ProverModuleExports> {
  if (options.proverModule) {
    return options.proverModule;
  }
  if (options.loadProverModule) {
    return options.loadProverModule();
  }
  if (options.proverModuleUrl) {
    return dynamicImport<ProverModuleExports>(options.proverModuleUrl);
  }
  throw new Error(
    'createLofCircuit: prover module not provided – supply `proverModule`, `loadProverModule`, or `proverModuleUrl`'
  );
}

async function dynamicImport<T>(url: string): Promise<T> {
  // The webpack/vite ignore hints keep popular bundlers from trying to statically analyze the string literal.
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  return import(/* webpackIgnore: true */ /* @vite-ignore */ url) as Promise<T>;
}

function stringifyValue(value: unknown): string {
  if (typeof value === 'string') {
    return value;
  }
  if (typeof value === 'number' || typeof value === 'bigint') {
    return value.toString();
  }
  if (value instanceof Uint8Array) {
    return bytesToHex(value);
  }
  if (value == null) {
    return '0';
  }
  if (typeof value === 'object' && 'toString' in value) {
    return String((value as { toString: () => string }).toString());
  }
  return String(value);
}

function bytesToHex(bytes: Uint8Array): string {
  const hex: string[] = [];
  for (const byte of bytes) {
    hex.push(byte.toString(16).padStart(2, '0'));
  }
  return hex.join('');
}

function toWitnessRecord(raw: unknown): WitnessRecord {
  if (raw instanceof Map) {
    const fromMap: WitnessRecord = {};
    for (const [key, val] of raw.entries()) {
      fromMap[String(key)] = stringifyValue(val);
    }
    return fromMap;
  }
  if (Array.isArray(raw)) {
    const fromArray: WitnessRecord = {};
    for (const entry of raw) {
      if (!Array.isArray(entry) || entry.length !== 2) {
        throw new Error(
          'compute_witness returned an array in an unexpected shape; expected [key, value] pairs'
        );
      }
      const [key, val] = entry;
      fromArray[String(key)] = stringifyValue(val);
    }
    return fromArray;
  }
  if (typeof raw === 'object' && raw !== null) {
    const result: WitnessRecord = {};
    for (const [key, val] of Object.entries(raw as Record<string, unknown>)) {
      result[key] = stringifyValue(val);
    }
    return result;
  }
  throw new Error(
    `compute_witness returned unsupported type: ${typeof raw}. Expected Map, object, or iterable of entries.`
  );
}

function coerceUint8Array(
  value:
    | Uint8Array
    | ArrayBuffer
    | ArrayBufferView
    | number[]
    | readonly number[]
): Uint8Array {
  if (value instanceof Uint8Array) {
    return value;
  }
  if (value instanceof ArrayBuffer) {
    return new Uint8Array(value);
  }
  if (Array.isArray(value)) {
    return Uint8Array.from(value);
  }
  if (ArrayBuffer.isView(value)) {
    const view = value as ArrayBufferView;
    return new Uint8Array(view.buffer.slice(view.byteOffset, view.byteOffset + view.byteLength));
  }
  throw new Error('Expected proof bytes to be a Uint8Array-compatible value');
}

export type InitializeOptions = CreateLofCircuitOptions;
export type BrowserToolkit = LofCircuit;

// Legacy aliases for backward compatibility (deprecated)
/** @deprecated Use CreateLofCircuitOptions instead */
export type InitializeToolkitOptions = CreateLofCircuitOptions;
/** @deprecated Use LofCircuit instead */
export type Toolkit = LofCircuit;
/** @deprecated Use createLofCircuit instead */
export const initializeToolkit = createLofCircuit;

function normalizeBundleRoot(root?: string): string | undefined {
  if (!root) {
    return undefined;
  }
  return root.endsWith('/') ? root.slice(0, -1) : root;
}

function resolveArtifactName(
  options: CreateLofCircuitOptions,
  bundleRoot?: string
): string | undefined {
  if (options.artifactName && options.artifactName.length > 0) {
    return options.artifactName;
  }

  const inferred =
    pickArtifactNameFromUrl(options.r1csUrl) ??
    pickArtifactNameFromUrl(options.provingKeyUrl) ??
    pickArtifactNameFromUrl(options.witnessModuleUrl);
  if (inferred) {
    return inferred;
  }

  if (bundleRoot) {
    const trimmed = bundleRoot.replace(/[#?].*$/, '');
    const segments = trimmed.split('/').filter(Boolean);
    const last = segments[segments.length - 1];
    if (last) {
      return last;
    }
  }

  return undefined;
}

function pickArtifactNameFromUrl(url?: string): string | undefined {
  if (!url) {
    return undefined;
  }
  const clean = url.split(/[?#]/)[0];
  if (!clean) {
    return undefined;
  }
  const filename = clean.substring(clean.lastIndexOf('/') + 1);
  if (filename.endsWith('_witness_wasm.js')) {
    return filename.replace('_witness_wasm.js', '');
  }
  if (filename.endsWith('_pk.bin')) {
    return filename.replace('_pk.bin', '');
  }
  if (filename.endsWith('.r1cs')) {
    return filename.replace('.r1cs', '');
  }
  return undefined;
}
